import numpy as np
import pandas as pd
import scipy.optimize as sc
import matplotlib.pyplot as plt

class SmartBeta:
    def __init__(self, stockPrices, scheme, rf=0.03):
        if not isinstance(stockPrices, pd.DataFrame):
            raise ValueError("stockPrices must be a pandas DataFrame")
        self.smartScheme = scheme
        self.prices = stockPrices
        self.rf = rf
        self.covMat = self._cov()
        self.mu = self._mu()
        self.lbsmb = 0.01
        self.ubsmb = 0.10
        self.tol = 1e-30

    # Existing methods (_cov, _mu, Constraint2, SR, MV, DR, RP, Function_SmartBeta) remain unchanged

    def portfolio_performance(self, weights):
        mu = np.array(self.mu)
        cov_mat = np.array(self.covMat)
        port_return = np.dot(weights, mu)
        port_vol = np.sqrt(np.dot(weights.T, np.dot(cov_mat, weights)))
        sharpe = (port_return - self.rf) / port_vol
        return {'Expected Return': port_return, 'Volatility': port_vol, 'Sharpe Ratio': sharpe}

    def weightingCalculation(self):
        weights = self.Function_SmartBeta()
        performance = self.portfolio_performance(weights)
        return weights, performance

    def backtest(self, benchmark_prices=None):
        returns = self.prices.pct_change().dropna()
        weights = self.Function_SmartBeta()
        portfolio_returns = (returns * weights).sum(axis=1)
        cumulative_returns = (1 + portfolio_returns).cumprod()
        if benchmark_prices is not None:
            benchmark_returns = benchmark_prices.pct_change().dropna()
            benchmark_cumulative = (1 + benchmark_returns).cumprod()
            return pd.DataFrame({'Portfolio': cumulative_returns, 'Benchmark': benchmark_cumulative})
        return cumulative_returns

    def plot_backtest(self, benchmark_prices=None):
        results = self.backtest(benchmark_prices)
        results.plot()
        plt.title(f'Backtest Results ({self.smartScheme})')
        plt.ylabel('Cumulative Return')
        plt.show()
